diff --git a/arch/arm64/boot/dts/allwinner/sun50i-h5-emlid-iota.dts b/arch/arm64/boot/dts/allwinner/sun50i-h5-emlid-iota.dts
index 3cf9b3f..74f14a7 100644
--- a/arch/arm64/boot/dts/allwinner/sun50i-h5-emlid-iota.dts
+++ b/arch/arm64/boot/dts/allwinner/sun50i-h5-emlid-iota.dts
@@ -107,6 +107,7 @@
     bus-width = <4>;
     non-removable;
     status = "okay";
+    boot-device = <2>;      /* mmc counter fix  */
 
     brcmf: bcrmf@1 {
         reg = <1>;
diff --git a/drivers/mmc/core/host.c b/drivers/mmc/core/host.c
index 1503412..6228070 100644
--- a/drivers/mmc/core/host.c
+++ b/drivers/mmc/core/host.c
@@ -344,6 +344,7 @@ struct mmc_host *mmc_alloc_host(int extra, struct device *dev)
 {
 	int err;
 	struct mmc_host *host;
+	u32 boot_device;
 
 	host = kzalloc(sizeof(struct mmc_host) + extra, GFP_KERNEL);
 	if (!host)
@@ -352,7 +353,12 @@ struct mmc_host *mmc_alloc_host(int extra, struct device *dev)
 	/* scanning will be enabled when we're ready */
 	host->rescan_disable = 1;
 
-	err = ida_simple_get(&mmc_host_ida, 0, 0, GFP_KERNEL);
+	if (!device_property_read_u32(dev, "boot-device", &boot_device)) {
+		err = ida_simple_get(&mmc_host_ida, boot_device, 0, GFP_KERNEL);
+	} else {
+		err = ida_simple_get(&mmc_host_ida, 0, 0, GFP_KERNEL);
+	}
+
 	if (err < 0) {
 		kfree(host);
 		return NULL;
